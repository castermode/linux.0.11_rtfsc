# Linux 0.11 文件写入代码执行流程

## 概述
在 Linux 0.11 中，文件写入是一个从用户态到内核态、再到硬件的完整过程。本文档详细描述从用户调用 `write()` 函数到数据最终写入磁盘的完整代码执行流程。

---

## 完整流程图

```
用户程序
   │
   ├─ write(fd, buf, count)              [lib/write.c]
   │
   ├─ int 0x80 (系统调用中断)
   │
   ├─ system_call                         [kernel/system_call.s]
   │
   ├─ sys_write(fd, buf, count)           [fs/read_write.c]
   │    ├─ 参数验证 (fd, count)
   │    ├─ 获取 inode
   │    └─ 根据文件类型分派：
   │         ├─ 管道: write_pipe()
   │         ├─ 字符设备: rw_char()
   │         ├─ 块设备: block_write()
   │         └─ 普通文件: file_write()   [fs/file_dev.c]
   │
   ├─ file_write(inode, filp, buf, count)
   │    │
   │    └─ 循环处理每个数据块：
   │         ├─ create_block() → _bmap()  [fs/inode.c]
   │         │    └─ 分配磁盘块 (处理直接块、一级间接、二级间接)
   │         │
   │         ├─ bread(dev, block)         [fs/buffer.c]
   │         │    └─ 读取磁盘块到缓冲区
   │         │
   │         ├─ 从用户空间复制数据到缓冲区
   │         │    └─ get_fs_byte(buf++)
   │         │
   │         ├─ 标记缓冲区为脏 (bh->b_dirt = 1)
   │         │
   │         └─ brelse(bh) 释放缓冲区
   │
   ├─ [后台/sync时] ll_rw_block(WRITE, bh)  [kernel/blk_drv/ll_rw_blk.c]
   │    │
   │    └─ make_request(major, WRITE, bh)
   │         ├─ 分配 request 结构
   │         └─ add_request() → 添加到请求队列
   │              └─ do_hd_request()       [kernel/blk_drv/hd.c]
   │
   └─ do_hd_request()
        ├─ 计算 CHS (柱面/磁头/扇区)
        ├─ hd_out() 发送写命令到硬盘控制器
        ├─ port_write() 写数据到硬盘
        └─ write_intr() 中断处理，完成写入
```

---

## 详细流程说明

### 1. 用户态：write() 系统调用封装
**文件：** `lib/write.c`

```c
_syscall3(int, write, int, fd, const char *, buf, off_t, count)
```

这个宏展开后生成如下代码：

```c
int write(int fd, const char *buf, off_t count)
{
    long __res;
    __asm__ volatile ("int $0x80"
        : "=a" (__res)
        : "0" (__NR_write),     // eax = 系统调用号 4
          "b" ((long)(fd)),      // ebx = 文件描述符
          "c" ((long)(buf)),     // ecx = 缓冲区地址
          "d" ((long)(count)));  // edx = 字节数
    if (__res >= 0)
        return (int) __res;
    errno = -__res;
    return -1;
}
```

**关键点：**
- 通过 `int 0x80` 触发系统调用中断
- eax 寄存器存放系统调用号
- ebx, ecx, edx 存放参数

---

### 2. 内核态：系统调用入口
**文件：** `kernel/system_call.s`

```assembly
system_call:
    cmpl $nr_system_calls-1,%eax     # 检查系统调用号是否有效
    ja bad_sys_call
    push %ds
    push %es
    push %fs
    pushl %edx                        # 保存参数
    pushl %ecx
    pushl %ebx
    movl $0x10,%edx                   # 设置 ds, es 指向内核数据段
    mov %dx,%ds
    mov %dx,%es
    movl $0x17,%edx                   # fs 指向用户数据段
    mov %dx,%fs
    call *sys_call_table(,%eax,4)     # 调用对应的系统调用函数
    pushl %eax                        # 保存返回值
    # ... 信号处理和调度 ...
```

**关键点：**
- 保存寄存器和段选择符
- 设置内核段和用户段
- 通过 `sys_call_table` 跳转到 `sys_write`

---

### 3. sys_write：写入请求分发
**文件：** `fs/read_write.c`

```c
int sys_write(unsigned int fd, char * buf, int count)
{
    struct file * file;
    struct m_inode * inode;
    
    // 1. 参数验证
    if (fd >= NR_OPEN || count < 0 || !(file=current->filp[fd]))
        return -EINVAL;
    if (!count)
        return 0;
    
    // 2. 获取 inode
    inode = file->f_inode;
    
    // 3. 根据文件类型分派
    if (inode->i_pipe)
        return (file->f_mode&2) ? write_pipe(inode,buf,count) : -EIO;
    if (S_ISCHR(inode->i_mode))                    // 字符设备
        return rw_char(WRITE, inode->i_zone[0], buf, count, &file->f_pos);
    if (S_ISBLK(inode->i_mode))                    // 块设备
        return block_write(inode->i_zone[0], &file->f_pos, buf, count);
    if (S_ISREG(inode->i_mode))                    // 普通文件
        return file_write(inode, file, buf, count);
    
    return -EINVAL;
}
```

**关键点：**
- 验证文件描述符有效性
- 根据 inode 类型（管道、字符设备、块设备、普通文件）分派到不同的处理函数
- 普通文件调用 `file_write()`

---

### 4. file_write：普通文件写入
**文件：** `fs/file_dev.c`

```c
int file_write(struct m_inode * inode, struct file * filp, char * buf, int count)
{
    off_t pos;
    int block, c;
    struct buffer_head * bh;
    char * p;
    int i = 0;

    // 处理追加模式
    if (filp->f_flags & O_APPEND)
        pos = inode->i_size;
    else
        pos = filp->f_pos;
    
    // 循环写入每个数据块
    while (i < count) {
        // 4.1 获取/创建文件对应的磁盘块号
        if (!(block = create_block(inode, pos/BLOCK_SIZE)))
            break;
        
        // 4.2 读取该磁盘块到缓冲区
        if (!(bh = bread(inode->i_dev, block)))
            break;
        
        // 4.3 计算块内偏移和写入字节数
        c = pos % BLOCK_SIZE;
        p = c + bh->b_data;
        c = BLOCK_SIZE - c;
        if (c > count-i) c = count-i;
        
        // 4.4 更新文件大小
        pos += c;
        if (pos > inode->i_size) {
            inode->i_size = pos;
            inode->i_dirt = 1;      // 标记 inode 为脏
        }
        
        // 4.5 从用户空间复制数据到缓冲区
        i += c;
        while (c-- > 0)
            *(p++) = get_fs_byte(buf++);
        
        // 4.6 标记缓冲区为脏并释放
        bh->b_dirt = 1;             // 关键：标记为脏，等待写回
        brelse(bh);
    }
    
    // 4.7 更新时间戳
    inode->i_mtime = CURRENT_TIME;
    if (!(filp->f_flags & O_APPEND)) {
        filp->f_pos = pos;
        inode->i_ctime = CURRENT_TIME;
    }
    
    return (i ? i : -1);
}
```

**关键点：**
- **延迟写入策略**：只是将数据写入缓冲区并标记为脏 (`b_dirt = 1`)，不立即写入磁盘
- 使用 `create_block()` 分配磁盘块
- 使用 `get_fs_byte()` 从用户空间复制数据（fs 段指向用户空间）
- 更新 inode 的大小和时间戳

---

### 5. create_block / _bmap：磁盘块映射
**文件：** `fs/inode.c`

```c
int create_block(struct m_inode * inode, int block)
{
    return _bmap(inode, block, 1);  // 1 表示创建模式
}

static int _bmap(struct m_inode * inode, int block, int create)
{
    struct buffer_head * bh;
    int i;
    
    if (block < 0)
        panic("_bmap: block<0");
    if (block >= 7+512+512*512)
        panic("_bmap: block>big");
    
    // 5.1 直接块 (0-6)：直接从 inode 获取
    if (block < 7) {
        if (create && !inode->i_zone[block]) {
            if ((inode->i_zone[block] = new_block(inode->i_dev))) {
                inode->i_ctime = CURRENT_TIME;
                inode->i_dirt = 1;
            }
        }
        return inode->i_zone[block];
    }
    
    // 5.2 一级间接块 (7-518)
    block -= 7;
    if (block < 512) {
        // 分配一级间接块
        if (create && !inode->i_zone[7]) {
            if ((inode->i_zone[7] = new_block(inode->i_dev))) {
                inode->i_dirt = 1;
                inode->i_ctime = CURRENT_TIME;
            }
        }
        if (!inode->i_zone[7])
            return 0;
        
        // 读取间接块
        if (!(bh = bread(inode->i_dev, inode->i_zone[7])))
            return 0;
        
        // 从间接块中获取/分配实际数据块
        i = ((unsigned short *)(bh->b_data))[block];
        if (create && !i) {
            if ((i = new_block(inode->i_dev))) {
                ((unsigned short *)(bh->b_data))[block] = i;
                bh->b_dirt = 1;
            }
        }
        brelse(bh);
        return i;
    }
    
    // 5.3 二级间接块 (519+)
    block -= 512;
    // ... 类似处理二级间接块 ...
}
```

**关键点：**
- **直接块**：前 7 个块直接存储在 inode 中
- **一级间接块**：第 8 个块指向包含 512 个块号的间接块
- **二级间接块**：第 9 个块指向间接块的间接块
- `new_block()` 从位图中分配新的磁盘块

---

### 6. bread：读取磁盘块到缓冲区
**文件：** `fs/buffer.c`

```c
struct buffer_head * bread(int dev, int block)
{
    struct buffer_head * bh;
    
    // 获取缓冲区（可能从缓存中获取）
    if (!(bh = getblk(dev, block)))
        panic("bread: getblk returned NULL\n");
    
    // 如果数据已经是最新的，直接返回
    if (bh->b_uptodate)
        return bh;
    
    // 否则从磁盘读取
    ll_rw_block(READ, bh);
    wait_on_buffer(bh);
    
    if (bh->b_uptodate)
        return bh;
    
    brelse(bh);
    return NULL;
}
```

**关键点：**
- 使用缓冲区缓存机制（buffer cache）
- 如果缓冲区中已有最新数据，避免磁盘 I/O
- `getblk()` 实现 LRU 缓存策略

---

### 7. 数据何时真正写入磁盘？

文件写入使用**延迟写入（Delayed Write）**策略，数据在以下情况被写入磁盘：

#### 7.1 sync 系统调用
**文件：** `fs/buffer.c`

```c
int sys_sync(void)
{
    int i;
    struct buffer_head * bh;
    
    sync_inodes();          // 先写 inode
    
    bh = start_buffer;
    for (i = 0; i < NR_BUFFERS; i++, bh++) {
        wait_on_buffer(bh);
        if (bh->b_dirt)
            ll_rw_block(WRITE, bh);    // 写脏缓冲区
    }
    return 0;
}
```

#### 7.2 缓冲区被回收时
当需要使用某个缓冲区而它又是脏的时候，先写回磁盘再重用。

#### 7.3 定期同步
系统定时调用 sync，将脏缓冲区写回磁盘。

---

### 8. ll_rw_block：底层块读写
**文件：** `kernel/blk_drv/ll_rw_blk.c`

```c
void ll_rw_block(int rw, struct buffer_head * bh)
{
    unsigned int major;
    
    if ((major = MAJOR(bh->b_dev)) >= NR_BLK_DEV ||
        !(blk_dev[major].request_fn)) {
        printk("Trying to read nonexistent block-device\n\r");
        return;
    }
    make_request(major, rw, bh);
}

static void make_request(int major, int rw, struct buffer_head * bh)
{
    struct request * req;
    
    // 8.1 检查是否真的需要写入
    lock_buffer(bh);
    if (rw == WRITE && !bh->b_dirt) {
        unlock_buffer(bh);
        return;                 // 不脏则无需写入
    }
    
    // 8.2 分配 request 结构
    // 读请求优先级高，写请求只能使用前 2/3 的队列
    if (rw == READ)
        req = request + NR_REQUEST;
    else
        req = request + ((NR_REQUEST*2)/3);
    
    // 8.3 找到空闲的 request
    while (--req >= request)
        if (req->dev < 0)
            break;
    
    if (req < request) {
        sleep_on(&wait_for_request);
        goto repeat;
    }
    
    // 8.4 填充 request 信息
    req->dev = bh->b_dev;
    req->cmd = rw;
    req->errors = 0;
    req->sector = bh->b_blocknr << 1;   // 块号 → 扇区号
    req->nr_sectors = 2;                 // 1 块 = 2 扇区 (1KB)
    req->buffer = bh->b_data;
    req->waiting = NULL;
    req->bh = bh;
    req->next = NULL;
    
    // 8.5 添加到请求队列并启动处理
    add_request(major + blk_dev, req);
}

static void add_request(struct blk_dev_struct * dev, struct request * req)
{
    struct request * tmp;
    
    req->next = NULL;
    cli();
    
    // 标记缓冲区不再脏（已加入队列）
    if (req->bh)
        req->bh->b_dirt = 0;
    
    if (!(tmp = dev->current_request)) {
        // 队列为空，立即启动
        dev->current_request = req;
        sti();
        (dev->request_fn)();        // 调用 do_hd_request()
        return;
    }
    
    // 电梯算法：按扇区号排序插入
    for ( ; tmp->next ; tmp = tmp->next) {
        if ((IN_ORDER(tmp, req) || !IN_ORDER(tmp, tmp->next)) &&
            IN_ORDER(req, tmp->next))
            break;
    }
    req->next = tmp->next;
    tmp->next = req;
    sti();
}
```

**关键点：**
- **电梯算法**：对请求按扇区号排序，减少磁头移动
- **读优先**：读请求可以使用整个队列，写请求只能用前 2/3
- 调用设备驱动的 `request_fn`（对于硬盘是 `do_hd_request`）

---

### 9. do_hd_request：硬盘驱动
**文件：** `kernel/blk_drv/hd.c`

```c
void do_hd_request(void)
{
    int i, r = 0;
    unsigned int block, dev;
    unsigned int sec, head, cyl;
    unsigned int nsect;
    
    INIT_REQUEST;           // 检查队列是否为空
    
    // 9.1 获取设备和扇区号
    dev = MINOR(CURRENT->dev);
    block = CURRENT->sector;
    
    // 9.2 转换为 CHS (柱面/磁头/扇区)
    block += hd[dev].start_sect;
    dev /= 5;
    __asm__("divl %4":"=a" (block),"=d" (sec)
            :"0" (block),"1" (0),"r" (hd_info[dev].sect));
    __asm__("divl %4":"=a" (cyl),"=d" (head)
            :"0" (block),"1" (0),"r" (hd_info[dev].head));
    sec++;
    nsect = CURRENT->nr_sectors;
    
    // 9.3 处理写请求
    if (CURRENT->cmd == WRITE) {
        // 发送写命令到硬盘控制器
        hd_out(dev, nsect, sec, head, cyl, WIN_WRITE, &write_intr);
        
        // 等待硬盘就绪
        for (i = 0; i < 3000 && !(r = inb_p(HD_STATUS) & DRQ_STAT); i++)
            /* nothing */ ;
        
        if (!r) {
            bad_rw_intr();
            goto repeat;
        }
        
        // 通过端口写入数据（256 个字 = 512 字节）
        port_write(HD_DATA, CURRENT->buffer, 256);
    } 
    // 读请求类似...
}

static void write_intr(void)
{
    // 10. 写中断处理
    if (win_result()) {
        bad_rw_intr();
        do_hd_request();
        return;
    }
    
    // 如果还有扇区要写
    if (--CURRENT->nr_sectors) {
        CURRENT->sector++;
        CURRENT->buffer += 512;
        do_hd = &write_intr;
        port_write(HD_DATA, CURRENT->buffer, 256);
        return;
    }
    
    // 完成，处理下一个请求
    end_request(1);
    do_hd_request();
}
```

**关键点：**
- 将逻辑块号转换为 CHS（柱面-磁头-扇区）地址
- 通过 I/O 端口与硬盘控制器通信
- 使用中断驱动方式：写入一个扇区后等待中断，再写下一个
- `port_write()` 宏使用 `outsw` 指令批量写入数据

---

## 关键数据结构

### buffer_head（缓冲区头）
```c
struct buffer_head {
    char * b_data;              // 数据指针 (1024 字节)
    unsigned long b_blocknr;    // 块号
    unsigned short b_dev;       // 设备号
    unsigned char b_uptodate;   // 数据是否最新
    unsigned char b_dirt;       // 是否被修改（脏）
    unsigned char b_count;      // 引用计数
    unsigned char b_lock;       // 是否被锁定
    struct task_struct * b_wait;// 等待队列
    struct buffer_head * b_prev;// 哈希链表
    struct buffer_head * b_next;
    struct buffer_head * b_prev_free;// 空闲链表
    struct buffer_head * b_next_free;
};
```

### request（I/O 请求）
```c
struct request {
    int dev;                    // 设备号 (-1 表示空闲)
    int cmd;                    // READ 或 WRITE
    int errors;                 // 错误次数
    unsigned long sector;       // 起始扇区号
    unsigned long nr_sectors;   // 扇区数
    char * buffer;              // 缓冲区地址
    struct task_struct * waiting;// 等待进程
    struct buffer_head * bh;    // 缓冲区头
    struct request * next;      // 下一个请求
};
```

### m_inode（内存中的 inode）
```c
struct m_inode {
    unsigned short i_mode;      // 文件类型和权限
    unsigned short i_uid;       // 用户 ID
    unsigned long i_size;       // 文件大小
    unsigned long i_mtime;      // 修改时间
    unsigned char i_gid;        // 组 ID
    unsigned char i_nlinks;     // 链接数
    unsigned short i_zone[9];   // 数据块索引
                                // [0-6]: 直接块
                                // [7]: 一级间接块
                                // [8]: 二级间接块
    // ... 其他字段 ...
};
```

---

## 性能优化机制

### 1. 缓冲区缓存（Buffer Cache）
- **作用**：减少磁盘 I/O，提高性能
- **策略**：LRU（最近最少使用）替换算法
- **大小**：根据内存大小动态分配（通常几百 KB）

### 2. 延迟写入（Delayed Write）
- **优点**：
  - 减少磁盘写操作次数
  - 相同块的多次写入可以合并
  - 提高系统响应速度
- **缺点**：
  - 系统崩溃可能丢失数据
  - 需要定期 sync

### 3. 电梯算法（Elevator Algorithm）
- **作用**：对磁盘请求排序，减少磁头移动距离
- **方法**：按扇区号将请求插入有序队列
- **效果**：显著提高磁盘吞吐量

### 4. 读写分离
- **读优先**：读请求可以使用整个请求队列
- **写限制**：写请求只能使用前 2/3 的队列
- **原因**：读操作通常更紧急（进程阻塞等待）

---

## 时序图

```
用户进程                内核                缓冲区管理              硬盘驱动
   |                     |                     |                     |
   |-- write() --------->|                     |                     |
   |                     |                     |                     |
   |                     |-- file_write() ---->|                     |
   |                     |                     |                     |
   |                     |<- 返回 (异步) ------|                     |
   |<-- 返回 ------------|                     |                     |
   |                     |                     |                     |
   | (进程继续执行)       |                     |                     |
   |                     |                     |                     |
   |                     |   [某个时刻触发 sync 或缓冲区满]           |
   |                     |                     |                     |
   |                     |                     |-- ll_rw_block() --->|
   |                     |                     |                     |
   |                     |                     |                     |-- 写磁盘
   |                     |                     |                     |
   |                     |                     |<- 中断 -------------|
   |                     |                     |                     |
   |                     |<- 标记完成 ---------|                     |
```

---

## 示例：写入 "Hello" 的完整过程

假设写入 5 字节 "Hello" 到新文件：

```c
int fd = open("test.txt", O_WRONLY | O_CREAT, 0644);
write(fd, "Hello", 5);
close(fd);
```

### 执行步骤：

1. **用户态**：`write(fd, "Hello", 5)` → `int 0x80`

2. **system_call**：保存寄存器 → 调用 `sys_write`

3. **sys_write**：
   - 验证 fd = 3（假设）
   - 获取 inode（新文件，大小为 0）
   - 类型是 S_IFREG → 调用 `file_write`

4. **file_write**：
   - pos = 0, count = 5
   - 循环 1 次（5 字节 < 1024）：
     - `create_block(inode, 0)` → 分配第一个数据块，假设分配到块号 1000
     - `bread(dev, 1000)` → 读取块 1000 到缓冲区（新块，内容为 0）
     - 从用户空间复制 "Hello" 到缓冲区偏移 0
     - `bh->b_dirt = 1` → 标记缓冲区为脏
     - `brelse(bh)` → 释放缓冲区（仍在缓存中）
   - 更新 inode：`i_size = 5`, `i_dirt = 1`, `i_mtime = 当前时间`
   - 返回 5（写入字节数）

5. **返回用户态**：write() 返回 5

6. **后台或 sync 时**：
   - `sys_sync()` 或缓冲区回收触发
   - `ll_rw_block(WRITE, bh)` → 创建写请求
   - `make_request()` → 填充 request 结构
   - `add_request()` → 添加到硬盘请求队列
   - `do_hd_request()` → 计算 CHS，发送写命令
   - `port_write()` → 通过端口写入 512 字节（含 "Hello"）
   - 硬盘完成 → 触发中断
   - `write_intr()` → 标记完成，唤醒等待进程

7. **inode 也需要写回**：
   - `sync_inodes()` 将 inode 写回磁盘的 inode 区

**时间消耗**：
- 用户到内核：微秒级（系统调用）
- 写入缓冲区：微秒级（内存操作）
- 返回用户态：微秒级
- 实际写磁盘：毫秒级（异步，后台完成）

---

## 常见问题

### Q1：为什么 write() 返回后数据还没写入磁盘？
**A**：Linux 0.11 使用延迟写入策略，只是将数据写入缓冲区。需要调用 `sync()` 或 `fsync()` 才能保证数据写入磁盘。

### Q2：如何保证数据不丢失？
**A**：
- 关键数据写入后调用 `sync()` 或 `fsync()`
- 系统会定期自动同步（update 守护进程）
- 正常关机时会调用 `sync()`

### Q3：文件最大能多大？
**A**：根据块索引结构：
- 直接块：7 块 × 1KB = 7 KB
- 一级间接：512 块 × 1KB = 512 KB
- 二级间接：512 × 512 × 1KB = 256 MB
- **总计**：约 256 MB

### Q4：为什么要使用缓冲区？
**A**：
- 磁盘速度远慢于内存（千倍差异）
- 减少磁盘 I/O 次数
- 允许异步写入，提高并发性
- 相同块的多次访问只需一次磁盘 I/O

### Q5：写入失败会怎样？
**A**：
- 如果在缓冲区阶段失败：返回错误给用户进程
- 如果磁盘写入失败：硬盘驱动会重试（最多 7 次），最终失败会导致缓冲区数据丢失，但用户进程已经返回

---

## 总结

Linux 0.11 的文件写入流程展现了经典的 Unix I/O 设计：

1. **分层设计**：用户层 → 系统调用层 → VFS 层 → 缓冲层 → 驱动层
2. **异步机制**：写入立即返回，实际 I/O 异步完成
3. **缓存优化**：缓冲区缓存大幅减少磁盘访问
4. **调度优化**：电梯算法优化磁盘访问顺序

尽管 Linux 0.11 代码简单（整个内核仅约 1 万行），但已经实现了现代操作系统的核心 I/O 机制。这些设计原理在今天的 Linux 内核中仍然适用，只是规模和复杂度大大增加。

---

## 相关文件清单

| 文件路径 | 主要功能 |
|---------|---------|
| `lib/write.c` | 用户态 write 系统调用封装 |
| `kernel/system_call.s` | 系统调用入口 |
| `fs/read_write.c` | sys_write 实现，请求分发 |
| `fs/file_dev.c` | 普通文件读写（file_write） |
| `fs/inode.c` | inode 管理，块映射（bmap） |
| `fs/buffer.c` | 缓冲区管理（bread, brelse） |
| `kernel/blk_drv/ll_rw_blk.c` | 底层块设备读写 |
| `kernel/blk_drv/hd.c` | 硬盘驱动 |
| `include/linux/fs.h` | 文件系统数据结构定义 |

